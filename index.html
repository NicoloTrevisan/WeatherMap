<!DOCTYPE html>
<html>
<head>
  <title>Cycling Route Planner</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Global Styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f8f9fa; } /* Light background */

    /* Container: holds sidebar and map */
    #container {
      height: 100vh;
      min-height: 0; /* Prevent flexbox overflow issues */
    }

    /* Desktop Layout: sidebar on left, map on right */
    @media (min-width: 601px) {
      #container { position: relative; }
      .controls {
        position: absolute;
        top: 0;
        left: 0;
        width: 320px; /* Slightly wider */
        height: 100vh;
        overflow-y: auto;
        z-index: 1500;
        padding: 15px; /* Increased padding */
        background: rgba(255, 255, 255, 0.98); /* Slightly opaque white */
        border-right: 1px solid #dee2e6;
        box-shadow: 2px 0 5px rgba(0,0,0,0.05); /* Subtle shadow */
        transition: transform 0.3s ease, opacity 0.3s ease; /* Added transform */
        transform: translateX(0);
        min-height: 0;
      }
      .controls.hidden {
          transform: translateX(-100%); /* Slide out */
          opacity: 0;
          pointer-events: none; /* Prevent interaction when hidden */
       }
      #map {
        position: absolute;
        top: 0;
        left: 320px; /* Match controls width */
        right: 0;
        bottom: 0;
        background: #e8f4f8;
        transition: left 0.3s ease;
        height: 100vh;
        min-height: 0;
      }
      /* Menu Toggle Button (desktop) positioned at bottom left */
      #menuToggle {
        position: absolute;
        bottom: 15px;
        left: 335px; /* Adjusted position */
        z-index: 4000;
        background: rgba(0,0,0,0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: left 0.3s ease, background-color 0.2s ease;
      }
       #menuToggle:hover { background: rgba(0,0,0,0.85); }
      /* Weather Toggle Icon for desktop */
      #weatherToggle {
        position: fixed;
        bottom: 15px;
        right: 15px;
        z-index: 4000;
        background: rgba(0,0,0,0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 50%; /* Make it round */
        cursor: pointer;
        font-size: 16px; /* Slightly larger icon */
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease;
      }
       #weatherToggle:hover { background: rgba(0,0,0,0.85); }
    }

    /* Mobile Layout: sidebar becomes a top bar and the map fills the rest */
    @media (max-width: 600px) {
      #container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        min-height: 0;
      }
      .controls {
        position: relative;
        width: 100%;
        height: auto; /* Allow content to determine height */
        max-height: 55vh; /* Limit height slightly more */
        overflow-y: auto; /* Allow scrolling */
        border-right: none;
        border-bottom: 1px solid #dee2e6;
        min-height: 0;
        background: rgb(255, 255, 255); /* Solid white on mobile */
        z-index: 1500;
        padding: 12px;
        transition: transform 0.3s ease, opacity 0.3s ease;
        transform: translateY(0);
      }
      .controls.hidden {
          /* Instead of display:none, slide it up */
          transform: translateY(-100%);
          opacity: 0;
          max-height: 0; /* Collapse height */
          padding: 0 12px; /* Remove padding when hidden */
          border-bottom: none;
          pointer-events: none;
      }
      #map {
        flex: 1 1 auto; /* Allow map to fill remaining space */
        position: relative;
        width: 100%;
        background: #e8f4f8;
        min-height: 0;
        z-index: 1000;
      }
      /* On mobile, menu toggle button fixed at top right */
      #menuToggle {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 4000;
        background: rgba(0,0,0,0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s ease;
      }
       #menuToggle:hover { background: rgba(0,0,0,0.85); }
      /* Weather Toggle Icon for mobile fixed at top left */
      #weatherToggle {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 4000;
        background: rgba(0,0,0,0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 50%; /* Make it round */
        cursor: pointer;
        font-size: 16px;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease;
      }
       #weatherToggle:hover { background: rgba(0,0,0,0.85); }
    }

    /* Common Controls Content */
    .controls h2 {
        margin-bottom: 16px; /* More space below title */
        font-size: 22px; /* Slightly larger */
        color: #333; /* Darker color */
        font-weight: 600;
        text-align: center;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
     }
    .section { margin-bottom: 20px; } /* More space between sections */
    .section h3 {
        margin-bottom: 12px; /* More space below section title */
        font-size: 16px;
        color: #007bff; /* Use theme color */
        font-weight: 600;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 6px;
     }
    .input-group {
      margin-bottom: 15px; /* More space between input groups */
      display: flex;
      flex-direction: column;
      gap: 5px; /* Reduced gap */
      position: relative;
    }
    .input-group label { font-size: 14px; color: #495057; font-weight: 500; }
    input[type="text"], input[type="datetime-local"], select, button {
      padding: 10px 12px; /* Adjusted padding */
      font-size: 15px; /* Slightly smaller font */
      border: 1px solid #ced4da;
      border-radius: 6px; /* Slightly less rounded */
      width: 100%;
      -webkit-appearance: none;
       appearance: none;
       background-color: #fff; /* Ensure background */
       transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
     input[type="text"]:focus, input[type="datetime-local"]:focus, select:focus {
        border-color: #80bdff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
     }
    button {
        background: #007bff;
        color: white;
        font-weight: 500;
        cursor: pointer;
        display: inline-flex; /* Align icon and text */
        align-items: center;
        justify-content: center;
        gap: 8px; /* Space between icon and text */
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover:not(:disabled) { background: #0056b3; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    button:active:not(:disabled) { background: #004a99; }
    button:disabled { background: #adb5bd; cursor: not-allowed; opacity: 0.7; }
    button .fa-spinner { margin-right: 8px; } /* Space for spinner */

    .stats-box {
      padding: 15px;
      background: #f8f9fa; /* Light grey background */
      border: 1px solid #e9ecef;
      border-radius: 6px;
      font-size: 14px;
      margin-top: 10px;
      line-height: 1.7; /* Improved line spacing */
    }
    .stats-box strong { color: #343a40; } /* Darker labels */
    .stats-box hr { border-top: 1px solid #e9ecef; margin: 8px 0; }
    .stats-box .fa-info-circle { cursor: help; color: #6c757d; margin-left: 4px; }

    .autocomplete-items { /* Keep as is, looks fine */
      position: absolute; top: 100%; left: 0; width: 100%;
      max-height: 200px; overflow-y: auto; z-index: 2000;
      background: white; border: 1px solid #ced4da; border-top: none;
      border-radius: 0 0 6px 6px; margin-top: -1px; /* Overlap border */
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .autocomplete-item { padding: 10px 12px; border-bottom: 1px solid #eee; line-height: 1.4; cursor: pointer; font-size: 14px; }
    .autocomplete-item:last-child { border-bottom: none; }
    .autocomplete-item:hover { background: #e9ecef; }
    .autocomplete-item div:first-child { font-weight: 500; } /* Main text */
    .autocomplete-item div:last-child { font-size: 0.85em; color: #6c757d; } /* Sub text */

    .error-message {
        color: #dc3545;
        padding: 8px 0;
        font-weight: 500; /* Make error text slightly bolder */
        font-size: 0.9em;
        display: flex; /* Align icon and text */
        align-items: center;
        gap: 5px;
    }
    #fileName { padding: 8px 0; color: #6c757d; font-style: italic; font-size: 0.9em; }

    /* Tabs Styles */
    .tabs { display: flex; gap: 5px; margin: 15px 0; }
    .tabs button {
      flex: 1; padding: 8px 10px; font-size: 14px; cursor: pointer;
      border: 1px solid transparent; /* Add border for structure */
      border-radius: 6px; background: #e9ecef; /* Lighter background for inactive */
      color: #495057; font-weight: 500;
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
     .tabs button:hover:not(.active) { background-color: #ced4da; }
    .tabs button.active {
      background: #007bff; color: #fff; font-weight: 600; border-color: #007bff;
    }
    .tab-content { margin-bottom: 16px; }

    /* Slider styling */
    input[type="range"] { /* Keep as is */ }
    /* ... rest of slider styles ... */

    /* Wind Marker Styling */
    .wind-marker i { font-size: 20px; color: #0056b3; }
    .wind-marker span { font-size: 12px; font-weight: bold; color: #333; }

    /* Helper class for loading state text */
    .loading-text { font-style: italic; color: #6c757d; }

    /* Route polyline style */
    .route-line { stroke: #007bff; stroke-width: 5; stroke-opacity: 0.8; }

    /* Tooltip styling */
    [title] {
        cursor: help; /* Indicate help is available */
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Sidebar Controls -->
    <div class="controls" id="controls">
      <h2>Cycling Route Planner</h2>
      <!-- Date & Time Header -->
      <div class="section" id="datetime-section">
        <label for="startTime">Departure Date & Time:</label>
        <input type="datetime-local" id="startTime" required>
      </div>
      <!-- Tabs -->
      <div class="tabs">
        <button type="button" id="tabGenerateRouteBtn" class="active" onclick="showTab('generateRoute', this)">Generate</button>
        <button type="button" id="tabRandomRouteBtn" onclick="showTab('generateRandom', this)">Random</button>
        <button type="button" id="tabSettingsBtn" onclick="showTab('settings', this)">Settings</button>
      </div>
      <!-- Tab Contents -->
      <div class="tab-content" id="generateRoute" style="display:block;">
        <div class="section">
          <h3>Generate Route</h3>
          <div class="input-group">
             <label for="startLocation">Start Address:</label>
            <input type="text" id="startLocation" placeholder="Enter start address" autocomplete="off">
          </div>
          <div class="input-group">
             <label for="endLocation">End Address:</label>
            <input type="text" id="endLocation" placeholder="Enter end address" autocomplete="off">
          </div>
          <div class="input-group">
            <button id="generateRouteButton" onclick="processInput(this.id)">
                <i class="fas fa-route"></i> Generate Route
            </button>
          </div>
        </div>
      </div>
      <div class="tab-content" id="generateRandom" style="display:none;">
        <div class="section">
          <h3>Generate Random Route</h3>
          <div class="input-group">
             <label for="randomLocation">Start Location (Optional):</label>
            <input type="text" id="randomLocation" placeholder="Uses map center if blank" autocomplete="off">
          </div>
          <div class="input-group">
            <label for="routeLengthSlider">Desired Length: <span id="routeLengthValue">50 km</span></label>
            <input type="range" id="routeLengthSlider" min="20" max="200" value="50" step="5">
            <div class="range-labels">20 km — 200 km</div>
          </div>
          <div class="input-group">
            <button id="generateRandomButton" onclick="bestRandomRouteGenerator(this.id)">
                <i class="fas fa-random"></i> Generate Best Random Route
            </button>
          </div>
        </div>
      </div>
      <div class="tab-content" id="settings" style="display:none;">
        <div class="section">
          <h3>Settings</h3>
          <div class="input-group">
            <label for="avgSpeed"><i class="fas fa-tachometer-alt"></i> Average Speed (km/h)</label>
            <select id="avgSpeed">
              <option>10</option> <option>15</option> <option>20</option>
              <option selected>22</option> <option>25</option> <option>30</option> <option>35</option>
            </select>
          </div>
          <div class="input-group">
            <label for="datapointsCount"><i class="fas fa-map-marker-alt"></i> # Weather Points along Route</label>
            <select id="datapointsCount">
              <option value="5">5</option> <option value="10" selected>10</option> <option value="20">20</option>
              <option value="30">30</option> <option value="50">50</option>
            </select>
          </div>
        </div>
      </div>
      <!-- GPX File Section -->
      <div class="section">
        <h3>GPX File</h3>
        <div class="input-group">
          <input type="file" id="gpxFile" accept=".gpx" hidden>
          <button id="loadGpxButton" onclick="document.getElementById('gpxFile').click()">
            <i class="fas fa-file-upload"></i> Load GPX File
          </button>
          <span id="fileName">No file selected</span>
        </div>
         <!-- GPX File Download -->
        <div class="input-group">
            <button id="saveGpxButton" onclick="saveRouteAsGPX()">
            <i class="fas fa-save"></i> Save Route as GPX
            </button>
        </div>
      </div>

      <!-- Clear Map Button -->
      <div class="section">
        <h3>Actions</h3>
        <div class="input-group">
          <button id="clearMapButton" onclick="clearMap(this.id)" style="background-color: #dc3545;"> <!-- Red color for clear -->
              <i class="fas fa-trash"></i> Clear Map & Inputs
          </button>
        </div>
      </div>
      <!-- Statistics -->
      <div class="section">
        <h3>Statistics & Weather</h3>
        <div class="stats-box" id="stats">
          <div id="errorDisplay" class="error-message"></div>
          <div id="statsContent">No route loaded. Use the options above or load a GPX file.</div>
          <!-- Statistics and weather info will appear here -->
        </div>
      </div>
      <div class="section">
        <p style="font-size: 13px; color: #6c757d; line-height: 1.5;">
           <i class="fas fa-info-circle"></i> <strong>Map Interaction:</strong><br>
           - Right-click (or long-press) on map to add waypoint.<br>
           - Right-click (or long-press) on blue waypoint marker to remove it.
        </p>
      </div>
    </div>
    <!-- Map -->
    <div id="map"></div>
  </div>

  <!-- Menu Toggle Button -->
  <div id="menuToggle" onclick="toggleMenu()">Hide Menu</div>

  <!-- Weather Toggle Icon -->
  <div id="weatherToggle" onclick="toggleWeatherLayer()" title="Toggle Weather Layer (Wind/Temp/Precip)">
    <i class="fas fa-wind"></i> <!-- Default icon -->
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script>
    /* -------------------------
       Define Custom Icons
       ------------------------- */
    const startIcon = L.divIcon({
      html: '<i class="fas fa-flag" style="color: green; font-size: 24px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></i>',
      iconSize: [24, 24], className: '', iconAnchor: [12, 24], popupAnchor: [0, -24]
    });
    const endIcon = L.divIcon({
      html: '<i class="fas fa-flag-checkered" style="color: red; font-size: 24px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></i>',
      iconSize: [24, 24], className: '', iconAnchor: [12, 24], popupAnchor: [0, -24]
    });
    // Default Leaflet blue marker used for intermediate waypoints

    /* -------------------------
       API Keys & Endpoints (IMPORTANT: Hide these in production!)
       ------------------------- */
    // WARNING: These keys are exposed client-side. For a real application,
    // use a backend proxy to protect them.
    const GRAPHHOPPER_KEY = '594dca35-3715-43ea-ac3b-fd23dc58808a';
    const OPENWEATHER_KEY = '154dc010adbb10c0549d6d077e64b073';
    const GRAPHHOPPER_URL = 'https://graphhopper.com/api/1/route';
    const OPENWEATHER_FORECAST_URL = 'https://api.openweathermap.org/data/2.5/forecast';
    const NOMINATIM_SEARCH_URL = 'https://nominatim.openstreetmap.org/search';

    /* -------------------------
       Global Variables & Initialization
       ------------------------- */
    let map, trackLayer;
    let waypoints = []; // L.Marker objects
    let windLayerGroup = L.layerGroup();
    let tempLayerGroup = L.layerGroup();
    let precipLayerGroup = L.layerGroup();
    let currentWeatherLayer = 'wind';
    let activeButtons = {}; // Store original button content { 'buttonId': 'originalHTML' }

    function initMap() {
      const isMobile = /Mobi|Android/i.test(navigator.userAgent);
      map = L.map('map', { zoomControl: false }).setView([51.8426, 5.8528], isMobile ? 12 : 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(map);
      L.control.zoom({ position: 'topright' }).addTo(map);

      document.getElementById('startTime').value = new Date().toISOString().slice(0, 16);

      document.getElementById('routeLengthSlider').addEventListener('input', function(e) {
        document.getElementById('routeLengthValue').textContent = e.target.value + " km";
      });

      // Setup autocomplete
      ['startLocation', 'endLocation', 'randomLocation'].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
          input.addEventListener('input', debounce(e => handleAutocomplete(e.target.value, input), 300));
          input.addEventListener('focusout', e => {
            setTimeout(() => {
                const relatedTargetIsAutocompleteItem = e.relatedTarget && e.relatedTarget.closest('.autocomplete-items');
                const listForThisInput = input.parentNode.querySelector('.autocomplete-items');
                if (!relatedTargetIsAutocompleteItem || (relatedTargetIsAutocompleteItem && relatedTargetIsAutocompleteItem !== listForThisInput)) {
                     if(listForThisInput) listForThisInput.remove();
                }
            }, 150);
          });
        }
      });

      // GPX file handling
      document.getElementById('gpxFile').addEventListener('change', function(e) {
        if (e.target.files.length > 0) {
            document.getElementById('fileName').textContent = e.target.files[0].name;
            // Trigger processing via the button's function to handle loading state
            processInput(document.getElementById('loadGpxButton').id);
        } else {
            document.getElementById('fileName').textContent = "No file selected";
        }
      });

      // Map interaction
      map.on('contextmenu', handleMapContextMenu);
      setupLongPressHandler();

      // Window resize
      window.addEventListener('resize', handleResize);

      // Show default tab
      showTab('generateRoute', document.getElementById('tabGenerateRouteBtn'));

      // Global click listener for autocomplete
      document.addEventListener('click', function(event) {
        const isClickInsideInput = event.target.matches('#startLocation, #endLocation, #randomLocation');
        const isClickInsideAutocomplete = event.target.closest('.autocomplete-items');
        if (!isClickInsideInput && !isClickInsideAutocomplete) {
            document.querySelectorAll('.autocomplete-items').forEach(el => el.remove());
        }
      });

      // Store original button states
      ['generateRouteButton', 'generateRandomButton', 'loadGpxButton', 'saveGpxButton', 'clearMapButton'].forEach(id => {
          const btn = document.getElementById(id);
          if (btn) activeButtons[id] = btn.innerHTML;
      });

      // Initial resize handler call
      handleResize();
    }
    initMap();


    /* -------------------------
       Loading State Management (Enhanced)
       ------------------------- */
    function showLoading(triggeringButtonId, loadingText = "Loading...") {
        // Disable all action buttons and store original content if not already stored
        Object.keys(activeButtons).forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.disabled = true;
                // If this is the button that triggered the action, show spinner and text
                if (id === triggeringButtonId) {
                    btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
                }
            }
        });
        document.getElementById('errorDisplay').innerHTML = ''; // Clear previous errors
        console.log(loadingText);
    }

    function hideLoading() {
        Object.keys(activeButtons).forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = activeButtons[id]; // Restore original content
            }
        });
    }


    /* -------------------------
       Polyline Extension (No changes)
       ------------------------- */
    L.Polyline.include({
      getDistance: function() { /* ... as before ... */
        return this.getLatLngs().reduce((acc, pt, i, arr) =>
          i > 0 ? acc + arr[i-1].distanceTo(pt) : acc, 0);
      },
      getPointAtDistance: function(target) { /* ... as before ... */
        let dist = 0;
        const pts = this.getLatLngs();
        if (!pts || pts.length === 0) return null;
        if (target <= 0) return pts[0];
        const totalDist = this.getDistance();
        if (target >= totalDist) return pts[pts.length - 1];

        for (let i = 1; i < pts.length; i++) {
          const segment = pts[i-1].distanceTo(pts[i]);
          if (segment > 1e-9 && dist + segment >= target) { // Avoid division by zero/tiny segments
            const frac = (target - dist) / segment;
            return L.latLng(
              pts[i-1].lat + frac * (pts[i].lat - pts[i-1].lat),
              pts[i-1].lng + frac * (pts[i].lng - pts[i-1].lng)
            );
          }
          dist += segment;
        }
        return pts[pts.length - 1]; // Fallback
      }
    });

    /* -------------------------
       Autocomplete Function (Minor refinement)
       ------------------------- */
    function debounce(func, timeout = 300) { /* ... as before ... */
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => { func.apply(this, args); }, timeout);
      };
    }

    async function handleAutocomplete(query, inputField) { /* ... mostly as before ... */
      const parentGroup = inputField.parentNode;
      const existingList = parentGroup.querySelector('.autocomplete-items');
      if (existingList) existingList.remove();
      if (query.length < 3) return;

      const loading = document.createElement('div');
      loading.className = 'autocomplete-items';
      loading.innerHTML = '<div class="autocomplete-item loading-text"><i>Searching...</i></div>';
      parentGroup.appendChild(loading);

      try {
        let typeParam = query.length < 6 ? 'city,town,village' : 'city,town,village,locality,road';
        const bounds = map.getBounds();
        const viewbox = `${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
        const url = `${NOMINATIM_SEARCH_URL}?format=json&limit=5&q=${encodeURIComponent(query)}&addressdetails=1&accept-language=en&dedupe=1&polygon_text=0&type=${typeParam}&viewbox=${viewbox}&bounded=1`;

        const response = await fetch(url);
        const data = await response.json();
        loading.remove();

        if (document.activeElement !== inputField || inputField.value.length < 3) return;
        const currentList = parentGroup.querySelector('.autocomplete-items');
        if (currentList) currentList.remove();

        const filteredResults = data.filter(item => !['waterway', 'house', 'pedestrian', 'hotel', 'platform', 'station'].includes(item.type));

        if (filteredResults.length === 0) {
            const noResult = document.createElement('div');
            noResult.className = 'autocomplete-items';
            noResult.innerHTML = '<div class="autocomplete-item loading-text"><i>No results found</i></div>';
            parentGroup.appendChild(noResult);
            return;
        }

        const list = document.createElement('div');
        list.className = 'autocomplete-items';
        filteredResults.forEach(item => {
          const div = document.createElement('div');
          div.className = 'autocomplete-item';
          const mainText = document.createElement('div');
          mainText.textContent = item.name || item.display_name.split(',')[0];
          const subText = document.createElement('div');
          let addressParts = [];
          if (item.address) {
              if(item.address.road && item.address.road !== mainText.textContent) addressParts.push(item.address.road);
              if(item.address.city && item.address.city !== mainText.textContent) addressParts.push(item.address.city);
              else if(item.address.town && item.address.town !== mainText.textContent) addressParts.push(item.address.town);
              else if(item.address.village && item.address.village !== mainText.textContent) addressParts.push(item.address.village);
              if(item.address.country) addressParts.push(item.address.country);
          }
          subText.textContent = addressParts.length > 0 ? addressParts.slice(0, 2).join(', ') : item.display_name.split(',').slice(1).join(',').trim();
          div.appendChild(mainText);
          div.appendChild(subText);
          div.addEventListener('mousedown', () => {
            inputField.value = item.display_name;
            list.remove();
          });
          list.appendChild(div);
        });
        parentGroup.appendChild(list);
      } catch (error) {
        const currentLoading = parentGroup.querySelector('.autocomplete-items');
        if (currentLoading) currentLoading.remove();
        console.error('Address suggestions unavailable:', error);
        const errorList = document.createElement('div');
        errorList.className = 'autocomplete-items';
        errorList.innerHTML = '<div class="autocomplete-item error-message" style="font-size: 1em;"><i>Suggestions failed</i></div>';
        parentGroup.appendChild(errorList);
        setTimeout(() => errorList.remove(), 2500);
      }
    }

    /* -------------------------
       Menu Toggle Functions (Adjusted for new slide animation)
       ------------------------- */
     function handleResize() {
          map.invalidateSize();
          const controls = document.getElementById('controls');
          const menuToggle = document.getElementById('menuToggle');
          if (window.innerWidth > 600) { // Desktop
              if (!controls.classList.contains('hidden')) {
                  document.getElementById('map').style.left = "320px";
                  menuToggle.style.left = "335px";
              } else {
                  document.getElementById('map').style.left = "0";
                  menuToggle.style.left = "15px"; // Position when menu hidden
              }
          } else { // Mobile
              document.getElementById('map').style.left = "0";
              menuToggle.style.left = ""; // Reset desktop positioning attribute
          }
      }

    function hideMenu() {
      document.getElementById('controls').classList.add('hidden');
      document.getElementById('menuToggle').innerText = "Show Menu";
      if (window.innerWidth > 600) {
        document.getElementById('map').style.left = "0";
        document.getElementById('menuToggle').style.left = "15px";
        setTimeout(() => { map.invalidateSize({ pan: false }); }, 310);
      } else {
          // On mobile, hiding controls doesn't change map position
          setTimeout(() => { map.invalidateSize({ pan: false }); }, 50);
      }
    }
    function showMenu() {
      document.getElementById('controls').classList.remove('hidden');
      document.getElementById('menuToggle').innerText = "Hide Menu";
      if (window.innerWidth > 600) {
          document.getElementById('map').style.left = "320px";
          document.getElementById('menuToggle').style.left = "335px";
      } else {
          document.getElementById('map').style.left = "0";
      }
       setTimeout(() => { map.invalidateSize({ pan: false }); }, 310);
    }
    function toggleMenu() {
      const controls = document.getElementById('controls');
      if (controls.classList.contains('hidden')) { showMenu(); } else { hideMenu(); }
    }

    /* -------------------------
       Tab Switching Functions
       ------------------------- */
    function showTab(tabId, buttonElement) { /* ... as before ... */
      const contents = document.getElementsByClassName('tab-content');
      for (let i = 0; i < contents.length; i++) {
        contents[i].style.display = 'none';
      }
      document.getElementById(tabId).style.display = 'block';
      const buttons = document.querySelectorAll('.tabs button');
      buttons.forEach(btn => btn.classList.remove('active'));
      if (buttonElement) {
          buttonElement.classList.add('active');
      }
      document.querySelectorAll('.autocomplete-items').forEach(el => el.remove());
    }

    /* -------------------------
       Route Generation Functions (with Loading States)
       ------------------------- */
    async function processInput(triggeringButtonId) {
      document.querySelectorAll('.autocomplete-items').forEach(el => el.remove());
      showLoading(triggeringButtonId, triggeringButtonId === 'loadGpxButton' ? "Loading GPX..." : "Generating...");

      try {
        const file = document.getElementById('gpxFile').files[0];
        const start = document.getElementById('startLocation').value.trim();
        const end = document.getElementById('endLocation').value.trim();

        clearRouteData(); // Clear previous route, markers, stats
        document.getElementById('statsContent').innerHTML = '<span class="loading-text">Processing...</span>';

        if (file) {
          const points = await parseGPX(file);
          if (!points || points.length < 2) throw new Error("GPX file contains insufficient points.");
          trackLayer = L.polyline(points, { className: 'route-line' }).addTo(map);
          map.fitBounds(trackLayer.getBounds(), { padding: [30, 30] });
          L.marker(points[0], { icon: startIcon, interactive: false }).addTo(map);
          L.marker(points[points.length - 1], { icon: endIcon, interactive: false }).addTo(map);
          waypoints = []; // No draggable waypoints for GPX
          await analyzeRoute(points);
        } else if (start && end) {
          const startCoords = await geocodeLocation(start);
          const endCoords = await geocodeLocation(end);

          const startMarker = L.marker(startCoords, { draggable: true, icon: startIcon }).addTo(map);
          startMarker.options.isFixed = true;
          startMarker.on('dragend', () => { waypoints[0] = startMarker; recalcRoute(); });
          waypoints.push(startMarker);

          const endMarker = L.marker(endCoords, { draggable: true, icon: endIcon }).addTo(map);
          endMarker.options.isFixed = true;
          endMarker.on('dragend', () => { waypoints[waypoints.length - 1] = endMarker; recalcRoute(); });
          waypoints.push(endMarker);

          map.fitBounds(L.latLngBounds([startCoords, endCoords]), { padding: [30, 30] });
          await recalcRoute();
        } else {
          // If triggered by Load GPX button but no file selected
          if (triggeringButtonId === 'loadGpxButton' && !file) {
              throw new Error('No GPX file selected to load.');
          } else {
              throw new Error('Please provide a GPX file OR both start and end addresses.');
          }
        }
        if (window.innerWidth <= 600) { hideMenu(); }
      } catch (error) {
        showError(error.message);
        document.getElementById('statsContent').innerHTML = 'Route generation failed.';
      } finally {
        hideLoading();
        // Reset file input if processing started from GPX load but failed before parsing
         if (triggeringButtonId === 'loadGpxButton' && !trackLayer) {
             document.getElementById('gpxFile').value = "";
             document.getElementById('fileName').textContent = "No file selected";
         }
      }
    }

    async function parseGPX(file) { /* ... as before ... */
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
          try {
            const gpx = new DOMParser().parseFromString(e.target.result, "text/xml");
            let latlngs = [];
            const trkpts = Array.from(gpx.getElementsByTagName('trkpt'));
            if (trkpts.length > 0) {
                latlngs = trkpts.map(pt => L.latLng(parseFloat(pt.getAttribute('lat')), parseFloat(pt.getAttribute('lon'))));
            } else { // Fallback to rtept
                const rtepts = Array.from(gpx.getElementsByTagName('rtept'));
                if (rtepts.length > 0) {
                     latlngs = rtepts.map(pt => L.latLng(parseFloat(pt.getAttribute('lat')), parseFloat(pt.getAttribute('lon'))));
                }
            }
            if (latlngs.length < 2) reject(new Error('GPX file needs at least two track/route points.'));
            resolve(latlngs.filter(ll => !isNaN(ll.lat) && !isNaN(ll.lng))); // Filter out invalid points
          } catch (error) { reject(new Error('Invalid or unreadable GPX file format.')); }
        };
        reader.onerror = () => reject(new Error('Failed to read the GPX file.'));
        reader.readAsText(file);
      });
    }

    async function recalcRoute() {
      if (waypoints.length < 2) return;

      // No separate loading state needed here as it's called by user interaction (drag)
      // or internally by processInput/addStopMarker which handle loading states.
      document.getElementById('statsContent').innerHTML = '<span class="loading-text">Recalculating...</span>';
      document.getElementById('errorDisplay').innerHTML = ''; // Clear previous errors

      if (trackLayer) map.removeLayer(trackLayer);
      windLayerGroup.clearLayers(); tempLayerGroup.clearLayers(); precipLayerGroup.clearLayers();

      const coordsArray = waypoints.map(m => m.getLatLng());

      try {
        const points = await calculateCyclingRoute(coordsArray);
        trackLayer = L.polyline(points, { className: 'route-line' }).addTo(map);
        await analyzeRoute(points);
        displayRecommendedHeading();
      } catch (e) {
        showError(`Route recalculation failed: ${e.message}`);
        document.getElementById('statsContent').innerHTML = 'Route recalculation failed.';
      }
      // No hideLoading() here, handled by parent calls or lack of initial showLoading()
    }

    async function calculateCyclingRoute(coordsArray) { /* ... as before ... */
      const params = new URLSearchParams({ vehicle: 'bike', elevation: 'true', points_encoded: 'false', key: GRAPHHOPPER_KEY });
      let url = `${GRAPHHOPPER_URL}?`;
      coordsArray.forEach(coord => { url += `point=${coord.lat},${coord.lng}&`; });
      url += params.toString();
      const response = await fetch(url);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: response.statusText }));
        console.error("GraphHopper Error:", errorData);
        throw new Error(`Routing API Error: ${errorData.message || 'Unknown error'}`);
      }
      const data = await response.json();
      if (!data.paths || data.paths.length === 0) throw new Error("Routing API Error: No route found.");
      return data.paths[0].points.coordinates.map(c => L.latLng(c[1], c[0]));
    }

    async function geocodeLocation(query) { /* ... as before ... */
      const response = await fetch(`${NOMINATIM_SEARCH_URL}?format=json&limit=1&q=${encodeURIComponent(query)}`);
      if (!response.ok) throw new Error(`Geocoding failed for "${query}" (Network error)`);
      const data = await response.json();
      if (!data || data.length === 0) throw new Error(`Location not found: "${query}"`);
      return L.latLng(parseFloat(data[0].lat), parseFloat(data[0].lon));
    }

    async function analyzeRoute(points) { /* ... mostly as before ... */
      document.getElementById('statsContent').innerHTML = '<span class="loading-text">Analyzing route, fetching weather...</span>';
      let errorCount = 0;

      try {
        const startTime = new Date(document.getElementById('startTime').value);
        if (isNaN(startTime)) throw new Error("Invalid departure date/time.");
        const avgSpeed = parseInt(document.getElementById('avgSpeed').value);
        if (isNaN(avgSpeed) || avgSpeed <= 0) throw new Error("Invalid average speed.");

        // Ensure trackLayer exists for distance calculation
         if (!trackLayer || typeof trackLayer.getDistance !== 'function') {
             trackLayer = L.polyline(points); // Create temporary if needed
             if (typeof trackLayer.getDistance !== 'function') {
                  throw new Error("Route data invalid for analysis.");
             }
         }

        const totalDistance = trackLayer.getDistance();
        const totalDistanceKm = totalDistance / 1000;
        const estimatedDurationHours = totalDistanceKm > 0 && avgSpeed > 0 ? totalDistanceKm / avgSpeed : 0;
        const estimatedDurationMs = estimatedDurationHours * 3600 * 1000;
        const estimatedEndTime = new Date(startTime.getTime() + estimatedDurationMs);

        let statsHTML = `
          <div><strong>Total Distance:</strong> ${totalDistanceKm.toFixed(1)} km</div>
          <div><strong>Est. Duration:</strong> ${formatDuration(estimatedDurationMs)}</div>
          <div><strong>Est. Arrival:</strong> ${estimatedEndTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
          <div><strong>Avg. Speed Setting:</strong> ${avgSpeed} km/h</div>
          <hr>
          <div id="weatherErrorDisplay" class="error-message" style="font-size: 0.9em;"></div>
        `;
        document.getElementById('statsContent').innerHTML = statsHTML;

        const numPoints = parseInt(document.getElementById('datapointsCount').value) || 10;
        const distancesToMark = [];
        if (numPoints >= 1 && totalDistance > 0) {
            distancesToMark.push(0); // Start point
            if (numPoints >= 2) {
                for (let i = 1; i < numPoints - 1; i++) {
                    distancesToMark.push((totalDistance * i) / (numPoints - 1));
                }
                distancesToMark.push(totalDistance); // End point
            } else { // Only 1 point requested
                 distancesToMark[0] = totalDistance / 2; // Middle point
            }
        }


        windLayerGroup.clearLayers(); tempLayerGroup.clearLayers(); precipLayerGroup.clearLayers();

        const weatherPromises = distancesToMark.map(async (dist, index) => {
          const point = trackLayer.getPointAtDistance(dist);
          if (!point) return;
          const km = dist / 1000;
          const estTimeEpoch = startTime.getTime() + (km / avgSpeed) * 3600000;
          const estTime = new Date(estTimeEpoch);

          try {
            await new Promise(resolve => setTimeout(resolve, index * 50)); // Stagger requests
            const forecastResponse = await fetch(`${OPENWEATHER_FORECAST_URL}?lat=${point.lat}&lon=${point.lng}&units=metric&appid=${OPENWEATHER_KEY}`);
            if (!forecastResponse.ok) {
              const error = await forecastResponse.json().catch(() => ({ message: `HTTP ${forecastResponse.status}` }));
              throw new Error(`Forecast API: ${error.message}`);
            }
            const forecastData = await forecastResponse.json();
            const estTimestamp = Math.floor(estTimeEpoch / 1000);
            let closestForecast = forecastData.list.reduce((prev, curr) => (Math.abs(curr.dt - estTimestamp) < Math.abs(prev.dt - estTimestamp) ? curr : prev));
            if (!closestForecast || Math.abs(closestForecast.dt - estTimestamp) > 3 * 3600) {
              console.warn(`No suitable forecast for ${km.toFixed(0)} km mark.`); return;
            }
            createWeatherMarkers(closestForecast, point, km, estTime);
          } catch (error) {
            errorCount++;
            console.error(`Forecast error at ${km.toFixed(1)} km:`, error);
             L.marker(point, { icon: L.divIcon({ html: '<i class="fas fa-exclamation-triangle" style="color: orange;"></i>', className: '', iconSize: [16, 16] }) })
               .addTo(map).bindPopup(`<b>${km.toFixed(0)} km Mark</b><hr>Forecast unavailable:<br>${error.message}`);
          }
        });
        await Promise.all(weatherPromises);

        if (errorCount > 0) {
            document.getElementById('weatherErrorDisplay').innerHTML = `<i class="fas fa-exclamation-triangle"></i> Failed to load weather for ${errorCount} point(s).`;
        }

        const tailwindScore = await computeTailwindScore(points, startTime, avgSpeed);
        document.getElementById('statsContent').innerHTML += `
            <div>
                <strong>Tailwind Score:</strong> ${tailwindScore.toFixed(1)} km/h
                <i class="fas fa-info-circle" title="Average headwind (-) or tailwind (+) component in km/h based on forecast along the route. Higher is better."></i>
            </div>`;

        map.addLayer(windLayerGroup); // Add default layer
        currentWeatherLayer = 'wind';
        updateWeatherToggleIcon();
      } catch (error) {
        console.error("Error during route analysis:", error);
        showError(`Analysis failed: ${error.message}`);
        document.getElementById('statsContent').innerHTML = 'Route analysis failed.';
      }
    }

    function createWeatherMarkers(forecast, point, km, estTime) { /* ... mostly as before, minor style tweaks ... */
      const tempC = Math.round(forecast.main.temp);
      const windSpeed = forecast.wind.speed * 3.6;
      const windDeg = forecast.wind.deg;
      const weatherDesc = forecast.weather[0].description;
      const weatherMain = forecast.weather[0].main || '';
      const rain = forecast.rain && forecast.rain['3h'] ? forecast.rain['3h'] : 0;
      const snow = forecast.snow && forecast.snow['3h'] ? forecast.snow['3h'] : 0;
      const forecastTime = new Date(forecast.dt * 1000);
      const directionStr = degreesToCompass(windDeg);
      let precipAmount = 0, precipIconClass = "fa-sun", precipColor = "gold", precipType = '';
      if (rain > 0) { precipAmount = rain; precipIconClass = rain > 1 ? "fa-cloud-showers-heavy" : "fa-cloud-rain"; precipColor = "blue"; precipType = '(Rain)'; }
      else if (snow > 0) { precipAmount = snow; precipIconClass = "fa-snowflake"; precipColor = "lightblue"; precipType = '(Snow)'; }
      else if (weatherMain.toLowerCase().includes('cloud')) { precipIconClass = "fa-cloud"; precipColor = "grey"; }

      const popupContent = `<b>${km.toFixed(0)} km Mark</b><hr><strong>Temp:</strong> ${tempC}°C<br><strong>Conditions:</strong> ${weatherDesc}<br><strong>Wind:</strong> ${windSpeed.toFixed(1)} km/h ${directionStr} (${windDeg}°)<br><strong>Precip (3h):</strong> ${precipAmount.toFixed(1)} mm ${precipType}<hr style="margin: 3px 0;"><i>Est. Arrival: ${estTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</i><br><i>Forecast for: ${forecastTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</i>`;

      // Wind Marker
      const windIcon = L.divIcon({ className: 'wind-marker', iconSize: [40, 40], iconAnchor: [20, 45], popupAnchor: [0, -40],
        html: `<div style="text-align:center; position: relative;"><div style="transform: rotate(${windDeg}deg); display:inline-block; position: absolute; top: -15px; left: 12px;"><i class="fas fa-long-arrow-alt-down"></i></div><span style="position: absolute; top: 5px; left: 0; width: 100%;">${windSpeed.toFixed(0)}</span></div>` });
      windLayerGroup.addLayer(L.marker(point, { icon: windIcon }).bindPopup(popupContent));

      // Temp Marker
      const tempIcon = L.divIcon({ className: '', iconSize: [40, 40], iconAnchor: [20, 20], popupAnchor: [0, -20],
        html: `<div style="text-align: center; background: rgba(255,255,255,0.75); border-radius: 50%; padding: 5px; border: 1px solid #ccc; width: 40px; height: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center;"><i class="fas fa-thermometer-half" style="color: ${tempC > 25 ? 'red' : tempC < 5 ? 'blue' : 'orange'};"></i><span style="font-weight:bold; font-size:12px; color: #333; line-height: 1;">${tempC}°</span></div>` });
      tempLayerGroup.addLayer(L.marker(point, { icon: tempIcon }).bindPopup(popupContent));

      // Precip Marker
      const precipIcon = L.divIcon({ className: '', iconSize: [40, 40], iconAnchor: [20, 20], popupAnchor: [0, -20],
        html: `<div style="text-align: center; background: rgba(255,255,255,0.75); border-radius: 50%; padding: 5px; border: 1px solid #ccc; width: 40px; height: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center;"><i class="fas ${precipIconClass}" style="color:${precipColor};"></i><span style="font-size:11px; color: #333; line-height: 1;">${precipAmount.toFixed(precipAmount < 1 ? 1 : 0)}mm</span></div>` });
      precipLayerGroup.addLayer(L.marker(point, { icon: precipIcon }).bindPopup(popupContent));
    }

    function degreesToCompass(degrees) { /* ... as before ... */
      const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      return directions[Math.round(((degrees % 360) + 360) % 360 / 22.5) % 16];
    }

    function formatDuration(milliseconds) { /* ... as before ... */
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        let durationString = "";
        if (hours > 0) durationString += `${hours} hr${hours > 1 ? 's' : ''} `;
        if (minutes > 0 || hours === 0) durationString += `${minutes} min${minutes > 1 ? 's' : ''}`;
        return durationString.trim() || "0 min";
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorDisplay');
      if (errorDiv) {
          // Prepend warning icon
          errorDiv.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${message}`;
      }
      console.error(message);
    }

    /* -------------------------
       Waypoint Management
       ------------------------- */
    function handleMapContextMenu(e) { /* ... as before ... */
        e.originalEvent.preventDefault();
        let foundMarkerToRemove = null;
        const clickPt = map.latLngToContainerPoint(e.latlng);
        map.eachLayer(layer => {
          if (layer instanceof L.Marker && layer.options.isExtra) {
            const markerPt = map.latLngToContainerPoint(layer.getLatLng());
            if (markerPt.distanceTo(clickPt) < 20) foundMarkerToRemove = layer;
          }
        });
        if (foundMarkerToRemove) removeWaypoint(foundMarkerToRemove);
        else if (waypoints.length >= 2) addStopMarker(e.latlng);
        else console.log("Add start/end points before adding waypoints.");
    }

    function setupLongPressHandler() { /* ... as before ... */
        let touchTimer; const longPressDuration = 1000;
        map.getContainer().addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                touchTimer = setTimeout(() => {
                    touchTimer = null;
                    const point = map.containerPointToLatLng([touch.clientX, touch.clientY]);
                    let foundMarkerToRemove = null; const pressPt = map.latLngToContainerPoint(point);
                    map.eachLayer(layer => {
                      if (layer instanceof L.Marker && layer.options.isExtra) {
                        const markerPt = map.latLngToContainerPoint(layer.getLatLng());
                        if (markerPt.distanceTo(pressPt) < 25) foundMarkerToRemove = layer;
                      }
                    });
                    if (foundMarkerToRemove) removeWaypoint(foundMarkerToRemove);
                    else if (waypoints.length >= 2) addStopMarker(point);
                    else console.log("Add start/end points before adding waypoints.");
                    e.preventDefault();
                }, longPressDuration);
            }
        }, { passive: false });
        map.getContainer().addEventListener('touchend', e => { if (touchTimer) clearTimeout(touchTimer); touchTimer = null; setTimeout(() => { map.invalidateSize(); }, 300); });
        map.getContainer().addEventListener('touchmove', e => { if (touchTimer) clearTimeout(touchTimer); touchTimer = null; });
    }

    function addStopMarker(latlng) { /* ... as before ... */
      if (waypoints.length < 2) { showError("Define start and end points first."); return; }
      const marker = L.marker(latlng, { draggable: true }).addTo(map); // Default blue icon
      marker.options.isExtra = true;
      marker.on('dragend', () => recalcRoute());
      marker.on('contextmenu', e => { e.originalEvent.preventDefault(); removeWaypoint(marker); });
      waypoints.splice(waypoints.length - 1, 0, marker); // Insert before end
      recalcRoute();
    }

    function removeWaypoint(markerToRemove) { /* ... as before ... */
        map.removeLayer(markerToRemove);
        waypoints = waypoints.filter(m => m !== markerToRemove);
        recalcRoute();
    }

    /* -------------------------
       Clear Map Function (with Confirmation)
       ------------------------- */
    function clearMap(triggeringButtonId) {
        // Confirmation dialog
        if (!confirm("Are you sure you want to clear the map, inputs, and statistics?")) {
            return; // User cancelled
        }

        showLoading(triggeringButtonId, "Clearing...");
        try {
            clearRouteData(); // Clear map layers, markers, waypoints, stats

            // Clear inputs
            document.getElementById('startLocation').value = '';
            document.getElementById('endLocation').value = '';
            document.getElementById('randomLocation').value = '';
            document.getElementById('gpxFile').value = "";
            document.getElementById('fileName').textContent = "No file selected";

            // Reset settings
            document.getElementById('avgSpeed').value = '22';
            document.getElementById('datapointsCount').value = '10';
            document.getElementById('routeLengthSlider').value = '50';
            document.getElementById('routeLengthValue').textContent = '50 km';
            document.getElementById('startTime').value = new Date().toISOString().slice(0, 16); // Reset time

            // Clear autocomplete lists
            document.querySelectorAll('.autocomplete-items').forEach(el => el.remove());

            // Reset recommended heading marker if implemented
            if (window.recommendedMarker) map.removeLayer(window.recommendedMarker); window.recommendedMarker = null;

            // Reset stats content to initial message
             document.getElementById('statsContent').innerHTML = 'No route loaded. Use the options above or load a GPX file.';

            console.log("Map cleared.");
        } catch(e) {
            showError("Error clearing map: " + e.message);
        } finally {
            hideLoading();
        }
    }

    // Helper to clear only route-related data
    function clearRouteData() { /* ... as before ... */
        if (trackLayer) map.removeLayer(trackLayer); trackLayer = null;
        windLayerGroup.clearLayers(); tempLayerGroup.clearLayers(); precipLayerGroup.clearLayers();
        waypoints.forEach(marker => map.removeLayer(marker)); waypoints = [];
        map.eachLayer(layer => { // Remove temporary markers like weather errors
            if (layer instanceof L.Marker && !layer.options.isFixed && !layer.options.isExtra) {
                if (!layer._icon || (layer._icon.innerHTML && layer._icon.innerHTML.includes('fa-exclamation-triangle'))) {
                     map.removeLayer(layer);
                }
            }
        });
        document.getElementById('statsContent').innerHTML = '';
        document.getElementById('errorDisplay').innerHTML = '';
    }

    /* -------------------------
       Save Map Function
       ------------------------- */
    function saveRouteAsGPX() { /* ... as before ... */
      if (!trackLayer || !trackLayer.getLatLngs || trackLayer.getLatLngs().length < 2) {
        showError("No valid route available to save!"); return;
      }
      const latlngs = trackLayer.getLatLngs();
      let gpx = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="Cycling Route Planner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n  <metadata>\n    <name>Cycling Route - ${new Date().toISOString().slice(0,10)}</name>\n    <time>${new Date().toISOString()}</time>\n  </metadata>\n  <trk>\n    <name>Route ${new Date().toISOString().slice(0,16)}</name>\n    <trkseg>\n`;
      latlngs.forEach(pt => { gpx += `      <trkpt lat="${pt.lat.toFixed(6)}" lon="${pt.lng.toFixed(6)}"></trkpt>\n`; });
      gpx += `    </trkseg>\n  </trk>\n</gpx>\n`;
      const blob = new Blob([gpx], { type: 'application/gpx+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.style.display = 'none'; a.href = url;
      const filename = `cycling_route_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}.gpx`;
      a.download = filename; document.body.appendChild(a); a.click();
      window.URL.revokeObjectURL(url); document.body.removeChild(a);
      // Optional: Brief feedback on the button
      const saveBtn = document.getElementById('saveGpxButton');
      if(saveBtn) {
          const originalHTML = activeButtons['saveGpxButton'];
          saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved!';
          saveBtn.disabled = true;
          setTimeout(() => {
              saveBtn.innerHTML = originalHTML;
              saveBtn.disabled = false;
          }, 1500);
      }
    }

    /* -------------------------
       Random Route Generator (with Loading States)
       ------------------------- */
    async function bestRandomRouteGenerator(triggeringButtonId) {
      document.querySelectorAll('.autocomplete-items').forEach(el => el.remove());
      showLoading(triggeringButtonId, "Generating...");

      try {
        let locInput = document.getElementById('randomLocation').value.trim();
        let center;
        document.getElementById('statsContent').innerHTML = `<span class="loading-text">${locInput ? `Geocoding "${locInput}"...` : 'Using map center...'}</span>`;
        if (locInput) center = await geocodeLocation(locInput);
        else center = map.getCenter();

        const routeLengthKm = parseInt(document.getElementById('routeLengthSlider').value);
        const routeLengthMeters = routeLengthKm * 1000;
        const startTime = new Date(document.getElementById('startTime').value); if (isNaN(startTime)) throw new Error("Invalid departure date/time.");
        const avgSpeed = parseInt(document.getElementById('avgSpeed').value); if (isNaN(avgSpeed) || avgSpeed <= 0) throw new Error("Invalid average speed.");

        clearRouteData();
        const numCandidates = 3;
        document.getElementById('statsContent').innerHTML = `<span class="loading-text">Generating ${numCandidates} candidate routes...</span>`;

        const candidatePromises = Array.from({ length: numCandidates }, (_, i) => (async () => {
            let seed = Math.floor(Math.random() * 100000);
            let url = `${GRAPHHOPPER_URL}?vehicle=bike&points_encoded=false&algorithm=round_trip&point=${center.lat},${center.lng}&round_trip.distance=${routeLengthMeters}&round_trip.seed=${seed}&key=${GRAPHHOPPER_KEY}`;
            try {
              let response = await fetch(url);
              if (!response.ok) { console.error(`Candidate ${i+1} failed:`, await response.text()); return null; }
              let data = await response.json();
              if (!data.paths || data.paths.length === 0) { console.error(`Candidate ${i+1} no path.`); return null; }
              let routePoints = data.paths[0].points.coordinates.map(c => L.latLng(c[1], c[0]));
              let actualDistance = computeTotalDistance(routePoints);
              if (Math.abs(actualDistance - routeLengthMeters) / routeLengthMeters > 0.5) { console.warn(`Candidate ${i+1} distance ${Math.round(actualDistance/1000)}km differs >50% from target ${routeLengthKm}km.`); }
              return { route: routePoints, seed: seed };
            } catch (e) { console.error(`Error generating candidate ${i+1}:`, e); return null; }
        })());

        const results = await Promise.all(candidatePromises);
        const validCandidates = results.filter(r => r !== null);
        if (validCandidates.length === 0) throw new Error("Could not generate any valid round-trip routes.");

        document.getElementById('statsContent').innerHTML = `<span class="loading-text">Analyzing ${validCandidates.length} routes for best tailwind...</span>`;

        const scoredCandidates = [];
        for (const candidate of validCandidates) {
            try {
                let score = await computeTailwindScore(candidate.route, startTime, avgSpeed);
                scoredCandidates.push({ ...candidate, score });
            } catch (e) { console.error("Error computing tailwind score:", e); scoredCandidates.push({ ...candidate, score: -Infinity }); }
        }

        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = scoredCandidates[0];
        document.getElementById('statsContent').innerHTML = `<span class="loading-text">Displaying best route (Seed: ${bestCandidate.seed})...</span>`;

        trackLayer = L.polyline(bestCandidate.route, { className: 'route-line' }).addTo(map);
        map.fitBounds(trackLayer.getBounds(), { padding: [30, 30] });
        L.marker(center, { icon: startIcon, interactive: false }).addTo(map);
        L.marker(center, { icon: endIcon, interactive: false }).addTo(map);
        waypoints = []; // No editable waypoints for random routes

        await analyzeRoute(bestCandidate.route);
        displayRecommendedHeading();
        if (window.innerWidth <= 600) { hideMenu(); }
      } catch (error) {
        showError(error.message);
        document.getElementById('statsContent').innerHTML = 'Random route generation failed.';
      } finally {
        hideLoading();
      }
    }

    /* -------------------------
       Helper Functions for Random Route (Tailwind etc.)
       ------------------------- */
    function computeTotalDistance(points) { /* ... as before ... */
      let total = 0; if (!points || points.length < 2) return 0;
      for (let i = 1; i < points.length; i++) { if (points[i-1] && points[i] && typeof points[i-1].distanceTo === 'function') { total += points[i-1].distanceTo(points[i]); } else { console.warn("Invalid point data in computeTotalDistance", i-1); } } return total;
    }
    function getPointAtDistanceFromRoute(points, target) { /* Uses Polyline method */ const tempPolyline = L.polyline(points); return tempPolyline.getPointAtDistance(target); }
    function computeBearing(start, end) { /* ... as before ... */
      if (!start || !end) return 0; const lat1 = start.lat * Math.PI / 180, lat2 = end.lat * Math.PI / 180, dLng = (end.lng - start.lng) * Math.PI / 180; const y = Math.sin(dLng) * Math.cos(lat2), x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng); const brng = Math.atan2(y, x) * 180 / Math.PI; return (brng + 360) % 360;
    }
    async function computeTailwindScore(routePoints, startTime, avgSpeed) { /* ... as before ... */
      if (!routePoints || routePoints.length < 2 || avgSpeed <= 0) return 0;
      const totalDistance = computeTotalDistance(routePoints); if (totalDistance <= 0) return 0;
      const sampleFractions = [0.25, 0.5, 0.75]; let totalTailwindComponent = 0, validSamples = 0;
      const weatherPromises = sampleFractions.map(async (frac, index) => {
        const targetDistance = totalDistance * frac;
        const samplePoint = getPointAtDistanceFromRoute(routePoints, targetDistance);
        const nextPoint = getPointAtDistanceFromRoute(routePoints, Math.min(targetDistance + 500, totalDistance));
        if (!samplePoint || !nextPoint || samplePoint.equals(nextPoint)) { console.warn(`Could not determine bearing at ${frac*100}%`); return null; }
        const bearing = computeBearing(samplePoint, nextPoint);
        const travelTimeMs = (targetDistance / 1000 / avgSpeed) * 3600 * 1000;
        const sampleTime = new Date(startTime.getTime() + travelTimeMs); const sampleTimestamp = Math.floor(sampleTime.getTime() / 1000);
        try {
          await new Promise(resolve => setTimeout(resolve, index * 75));
          const forecastResponse = await fetch(`${OPENWEATHER_FORECAST_URL}?lat=${samplePoint.lat}&lon=${samplePoint.lng}&units=metric&appid=${OPENWEATHER_KEY}`);
          if (!forecastResponse.ok) { console.warn(`Weather fetch failed for tailwind score at ${frac*100}%`); return null; }
          const forecastData = await forecastResponse.json();
          let bestEntry = forecastData.list.reduce((prev, curr) => (Math.abs(curr.dt - sampleTimestamp) < Math.abs(prev.dt - sampleTimestamp) ? curr : prev));
          if (!bestEntry || Math.abs(bestEntry.dt - sampleTimestamp) > 3 * 3600) { console.warn(`No suitable forecast for tailwind score at ${frac*100}%`); return null; }
          const windSpd_kmh = bestEntry.wind.speed * 3.6; const windDir = bestEntry.wind.deg;
          let angleDiffDegrees = windDir - bearing;
          while (angleDiffDegrees <= -180) angleDiffDegrees += 360; while (angleDiffDegrees > 180) angleDiffDegrees -= 360;
          const tailwindComponent = windSpd_kmh * Math.cos(angleDiffDegrees * Math.PI / 180);
          return tailwindComponent;
        } catch (e) { console.error(`Error computing tailwind at sample ${frac*100}%:`, e); return null; }
      });
      const results = await Promise.all(weatherPromises);
      results.forEach(component => { if (component !== null) { totalTailwindComponent += component; validSamples++; } });
      return validSamples > 0 ? totalTailwindComponent / validSamples : 0;
    }

    /* -------------------------
       Recommended Heading (Placeholder)
       ------------------------- */
    function displayRecommendedHeading() { /* ... as before ... */
        if (window.recommendedMarker) map.removeLayer(window.recommendedMarker); window.recommendedMarker = null;
    }

    /* -------------------------
       Weather Layer Toggle
       ------------------------- */
    function toggleWeatherLayer() { /* ... as before ... */
        map.removeLayer(windLayerGroup); map.removeLayer(tempLayerGroup); map.removeLayer(precipLayerGroup);
        if (currentWeatherLayer === 'wind') { map.addLayer(tempLayerGroup); currentWeatherLayer = 'temp'; }
        else if (currentWeatherLayer === 'temp') { map.addLayer(precipLayerGroup); currentWeatherLayer = 'precip'; }
        else { map.addLayer(windLayerGroup); currentWeatherLayer = 'wind'; }
        updateWeatherToggleIcon();
    }
    function updateWeatherToggleIcon() { /* ... as before ... */
        const iconElement = document.querySelector('#weatherToggle i'); if (!iconElement) return;
        const toggleButton = document.getElementById('weatherToggle');
        switch (currentWeatherLayer) {
            case 'wind': iconElement.className = 'fas fa-wind'; toggleButton.title = 'Showing Wind (Click to toggle Temp)'; break;
            case 'temp': iconElement.className = 'fas fa-thermometer-half'; toggleButton.title = 'Showing Temp (Click to toggle Precip)'; break;
            case 'precip': iconElement.className = 'fas fa-cloud-showers-heavy'; toggleButton.title = 'Showing Precip (Click to toggle Wind)'; break;
            default: iconElement.className = 'fas fa-layer-group'; toggleButton.title = 'Toggle Weather Layer';
        }
    }

  </script>
</body>
</html>